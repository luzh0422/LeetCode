//
// Created by luzehui on 2024/7/10.
//

#include "LeetCode2970.h"

/**
 * 分类讨论 + 双指针 + 前后缀，删除严格递增数组内某连续区间后剩余部分仍严格递增。删除区间可能是nums的某个：1、后缀；2、前缀；3、中段(非前后缀)。

 *  其中1、删除某个后缀只需找到nums的最长严格递增前缀结尾i，i+1及其前方每个点都可作为删除起点start(删除[start,n-1]，剩余前缀严格递增)，共i+2种方案。
 *     2、删除前缀情况同理，共n-j+1种方案。
 *     3、删除中段可在获取前后缀的基础上，枚举保留的后缀部分[r,n-1]起点r，在递增前缀中查找值小于nums[r]的最大位置i(剩余前缀[0,i]与保留后缀[r,n-1]严格递增)，从i+1开始向前均可作为删除起点，对任意r，删除起点i存在i+2个(2、中已计算只保留后缀情况)。
 *   PS：2、3方案可同步求解，从后向前枚举递增后缀起点r的同时在递增前缀搜索最大删除起点i，对每个r直接累加合法删除起点数i+2即可。
 */

int LeetCode2970::incremovableSubarrayCount(vector<int> &nums) {
    int n = nums.size(), i = 0;
    // 找到删除后缀的起始点；
    while (i < n - 1 && nums[i] < nums[i + 1]) {
        i++;
    }
    // 避免在求解前缀和后缀情况下的重复删除；
    if (i == n - 1) {
        return n * (n + 1) / 2;
    }
    int ans = i + 2;
    // 找到删除前缀 和 中段的情况；
    // 在第一层遍历时，就拿到了全部删除前缀的数字；
    for (int j = n - 1; j >= 0 && (j == n - 1 || nums[j] < nums[j + 1]); --j) {
        while (i >= 0 && nums[i] >= nums[j]) {
            --i;
        }
        ans += i + 2;
    }
    return ans;
}
